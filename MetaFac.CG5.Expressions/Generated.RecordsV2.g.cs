#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: RecordsV2.2.9
// Metadata : MetaFac.CG5.Expressions.Schema
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Memory;
using MetaFac.Mutability;
using MetaFac.CG4.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Numerics;

namespace MetaFac.CG5.Expressions
{


    public abstract record EntityBase : IFreezable, IEntityBase
    {
        public EntityBase() { }
        public EntityBase(EntityBase? source) { }
        public EntityBase(IEntityBase? source) { }
        public const int EntityTag = 0;
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();
        public virtual bool Equals(EntityBase? other) => true;
        public override int GetHashCode() => 0;
        public bool IsFreezable() => false;
        public bool IsFrozen() => true;
        public void Freeze() { }
        public bool TryFreeze() => false;
    }


    public abstract partial record Node : EntityBase, INode
    {
    }
    public sealed class Node_Factory : IEntityFactory<INode, Node>
    {
        private static readonly Node_Factory _instance = new Node_Factory();
        public static Node_Factory Instance => _instance;

        public Node? CreateFrom(INode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case ErrorNode.EntityTag: return ErrorNode_Factory.Instance.CreateFrom((IErrorNode)source);
                case ConstantNode.EntityTag: return ConstantNode_Factory.Instance.CreateFrom((IConstantNode)source);
                case NullConstantNode.EntityTag: return NullConstantNode_Factory.Instance.CreateFrom((INullConstantNode)source);
                case BooleanConstantNode.EntityTag: return BooleanConstantNode_Factory.Instance.CreateFrom((IBooleanConstantNode)source);
                case StringConstantNode.EntityTag: return StringConstantNode_Factory.Instance.CreateFrom((IStringConstantNode)source);
                case NumericConstantNode.EntityTag: return NumericConstantNode_Factory.Instance.CreateFrom((INumericConstantNode)source);
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                case OperatorNode.EntityTag: return OperatorNode_Factory.Instance.CreateFrom((IOperatorNode)source);
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                case VariableNode.EntityTag: return VariableNode_Factory.Instance.CreateFrom((IVariableNode)source);
                case UnaryExpressionNode.EntityTag: return UnaryExpressionNode_Factory.Instance.CreateFrom((IUnaryExpressionNode)source);
                case BinaryExpressionNode.EntityTag: return BinaryExpressionNode_Factory.Instance.CreateFrom((IBinaryExpressionNode)source);
                case TertiaryExpressionNode.EntityTag: return TertiaryExpressionNode_Factory.Instance.CreateFrom((ITertiaryExpressionNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(Node)} from {source.GetType().Name}");
            }
        }

        public Node Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(Node)}");
    }
    public partial record Node : EntityBase, INode
    {
        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;


        public Node() : base()
        {
        }

        public Node(Node? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public Node(INode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public virtual bool Equals(Node? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class ErrorNode_Factory : IEntityFactory<IErrorNode, ErrorNode>
    {
        private static readonly ErrorNode_Factory _instance = new ErrorNode_Factory();
        public static ErrorNode_Factory Instance => _instance;

        public ErrorNode? CreateFrom(IErrorNode? source)
        {
            if (source is null) return null;
            if (source is ErrorNode thisEntity) return thisEntity;
            return new ErrorNode(source);
        }

        private static readonly ErrorNode _empty = new ErrorNode();
        public ErrorNode Empty => _empty;
    }
    public partial record ErrorNode : Node, IErrorNode
    {
        public new const int EntityTag = 2;
        protected override int OnGetEntityTag() => EntityTag;

        public String? Message { get; init; }
        String? IErrorNode.Message => Message;

        public ErrorNode() : base()
        {
        }

        public ErrorNode(ErrorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Message = source.Message;
        }

        public ErrorNode(IErrorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Message = source.Message;
        }

        public virtual bool Equals(ErrorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Message.ValueEquals(other.Message)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Message.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public abstract partial record ConstantNode : Node, IConstantNode
    {
    }
    public sealed class ConstantNode_Factory : IEntityFactory<IConstantNode, ConstantNode>
    {
        private static readonly ConstantNode_Factory _instance = new ConstantNode_Factory();
        public static ConstantNode_Factory Instance => _instance;

        public ConstantNode? CreateFrom(IConstantNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case NullConstantNode.EntityTag: return NullConstantNode_Factory.Instance.CreateFrom((INullConstantNode)source);
                case BooleanConstantNode.EntityTag: return BooleanConstantNode_Factory.Instance.CreateFrom((IBooleanConstantNode)source);
                case StringConstantNode.EntityTag: return StringConstantNode_Factory.Instance.CreateFrom((IStringConstantNode)source);
                case NumericConstantNode.EntityTag: return NumericConstantNode_Factory.Instance.CreateFrom((INumericConstantNode)source);
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                case OperatorNode.EntityTag: return OperatorNode_Factory.Instance.CreateFrom((IOperatorNode)source);
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(ConstantNode)} from {source.GetType().Name}");
            }
        }

        public ConstantNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(ConstantNode)}");
    }
    public partial record ConstantNode : Node, IConstantNode
    {
        public new const int EntityTag = 3;
        protected override int OnGetEntityTag() => EntityTag;


        public ConstantNode() : base()
        {
        }

        public ConstantNode(ConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public ConstantNode(IConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public virtual bool Equals(ConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class NullConstantNode_Factory : IEntityFactory<INullConstantNode, NullConstantNode>
    {
        private static readonly NullConstantNode_Factory _instance = new NullConstantNode_Factory();
        public static NullConstantNode_Factory Instance => _instance;

        public NullConstantNode? CreateFrom(INullConstantNode? source)
        {
            if (source is null) return null;
            if (source is NullConstantNode thisEntity) return thisEntity;
            return new NullConstantNode(source);
        }

        private static readonly NullConstantNode _empty = new NullConstantNode();
        public NullConstantNode Empty => _empty;
    }
    public partial record NullConstantNode : ConstantNode, INullConstantNode
    {
        public new const int EntityTag = 4;
        protected override int OnGetEntityTag() => EntityTag;


        public NullConstantNode() : base()
        {
        }

        public NullConstantNode(NullConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public NullConstantNode(INullConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public virtual bool Equals(NullConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class BooleanConstantNode_Factory : IEntityFactory<IBooleanConstantNode, BooleanConstantNode>
    {
        private static readonly BooleanConstantNode_Factory _instance = new BooleanConstantNode_Factory();
        public static BooleanConstantNode_Factory Instance => _instance;

        public BooleanConstantNode? CreateFrom(IBooleanConstantNode? source)
        {
            if (source is null) return null;
            if (source is BooleanConstantNode thisEntity) return thisEntity;
            return new BooleanConstantNode(source);
        }

        private static readonly BooleanConstantNode _empty = new BooleanConstantNode();
        public BooleanConstantNode Empty => _empty;
    }
    public partial record BooleanConstantNode : ConstantNode, IBooleanConstantNode
    {
        public new const int EntityTag = 5;
        protected override int OnGetEntityTag() => EntityTag;

        public Boolean Value { get; init; }
        Boolean IBooleanConstantNode.Value => Value;

        public BooleanConstantNode() : base()
        {
        }

        public BooleanConstantNode(BooleanConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public BooleanConstantNode(IBooleanConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public virtual bool Equals(BooleanConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Value.ValueEquals(other.Value)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class StringConstantNode_Factory : IEntityFactory<IStringConstantNode, StringConstantNode>
    {
        private static readonly StringConstantNode_Factory _instance = new StringConstantNode_Factory();
        public static StringConstantNode_Factory Instance => _instance;

        public StringConstantNode? CreateFrom(IStringConstantNode? source)
        {
            if (source is null) return null;
            if (source is StringConstantNode thisEntity) return thisEntity;
            return new StringConstantNode(source);
        }

        private static readonly StringConstantNode _empty = new StringConstantNode();
        public StringConstantNode Empty => _empty;
    }
    public partial record StringConstantNode : ConstantNode, IStringConstantNode
    {
        public new const int EntityTag = 6;
        protected override int OnGetEntityTag() => EntityTag;

        public String? Value { get; init; }
        String? IStringConstantNode.Value => Value;

        public StringConstantNode() : base()
        {
        }

        public StringConstantNode(StringConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public StringConstantNode(IStringConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public virtual bool Equals(StringConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Value.ValueEquals(other.Value)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public abstract partial record NumericConstantNode : ConstantNode, INumericConstantNode
    {
    }
    public sealed class NumericConstantNode_Factory : IEntityFactory<INumericConstantNode, NumericConstantNode>
    {
        private static readonly NumericConstantNode_Factory _instance = new NumericConstantNode_Factory();
        public static NumericConstantNode_Factory Instance => _instance;

        public NumericConstantNode? CreateFrom(INumericConstantNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(NumericConstantNode)} from {source.GetType().Name}");
            }
        }

        public NumericConstantNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(NumericConstantNode)}");
    }
    public partial record NumericConstantNode : ConstantNode, INumericConstantNode
    {
        public new const int EntityTag = 7;
        protected override int OnGetEntityTag() => EntityTag;


        public NumericConstantNode() : base()
        {
        }

        public NumericConstantNode(NumericConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public NumericConstantNode(INumericConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public virtual bool Equals(NumericConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class IntegerConstantNode_Factory : IEntityFactory<IIntegerConstantNode, IntegerConstantNode>
    {
        private static readonly IntegerConstantNode_Factory _instance = new IntegerConstantNode_Factory();
        public static IntegerConstantNode_Factory Instance => _instance;

        public IntegerConstantNode? CreateFrom(IIntegerConstantNode? source)
        {
            if (source is null) return null;
            if (source is IntegerConstantNode thisEntity) return thisEntity;
            return new IntegerConstantNode(source);
        }

        private static readonly IntegerConstantNode _empty = new IntegerConstantNode();
        public IntegerConstantNode Empty => _empty;
    }
    public partial record IntegerConstantNode : NumericConstantNode, IIntegerConstantNode
    {
        public new const int EntityTag = 8;
        protected override int OnGetEntityTag() => EntityTag;

        public Int64 Value { get; init; }
        Int64 IIntegerConstantNode.Value => Value;

        public IntegerConstantNode() : base()
        {
        }

        public IntegerConstantNode(IntegerConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public IntegerConstantNode(IIntegerConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public virtual bool Equals(IntegerConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Value.ValueEquals(other.Value)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class DoubleConstantNode_Factory : IEntityFactory<IDoubleConstantNode, DoubleConstantNode>
    {
        private static readonly DoubleConstantNode_Factory _instance = new DoubleConstantNode_Factory();
        public static DoubleConstantNode_Factory Instance => _instance;

        public DoubleConstantNode? CreateFrom(IDoubleConstantNode? source)
        {
            if (source is null) return null;
            if (source is DoubleConstantNode thisEntity) return thisEntity;
            return new DoubleConstantNode(source);
        }

        private static readonly DoubleConstantNode _empty = new DoubleConstantNode();
        public DoubleConstantNode Empty => _empty;
    }
    public partial record DoubleConstantNode : NumericConstantNode, IDoubleConstantNode
    {
        public new const int EntityTag = 9;
        protected override int OnGetEntityTag() => EntityTag;

        public Double Value { get; init; }
        Double IDoubleConstantNode.Value => Value;

        public DoubleConstantNode() : base()
        {
        }

        public DoubleConstantNode(DoubleConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public DoubleConstantNode(IDoubleConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public virtual bool Equals(DoubleConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Value.ValueEquals(other.Value)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class VariableNode_Factory : IEntityFactory<IVariableNode, VariableNode>
    {
        private static readonly VariableNode_Factory _instance = new VariableNode_Factory();
        public static VariableNode_Factory Instance => _instance;

        public VariableNode? CreateFrom(IVariableNode? source)
        {
            if (source is null) return null;
            if (source is VariableNode thisEntity) return thisEntity;
            return new VariableNode(source);
        }

        private static readonly VariableNode _empty = new VariableNode();
        public VariableNode Empty => _empty;
    }
    public partial record VariableNode : Node, IVariableNode
    {
        public new const int EntityTag = 10;
        protected override int OnGetEntityTag() => EntityTag;

        public String? Name { get; init; }
        String? IVariableNode.Name => Name;

        public VariableNode() : base()
        {
        }

        public VariableNode(VariableNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Name = source.Name;
        }

        public VariableNode(IVariableNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Name = source.Name;
        }

        public virtual bool Equals(VariableNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Name.ValueEquals(other.Name)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Name.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public abstract partial record OperatorNode : ConstantNode, IOperatorNode
    {
    }
    public sealed class OperatorNode_Factory : IEntityFactory<IOperatorNode, OperatorNode>
    {
        private static readonly OperatorNode_Factory _instance = new OperatorNode_Factory();
        public static OperatorNode_Factory Instance => _instance;

        public OperatorNode? CreateFrom(IOperatorNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(OperatorNode)} from {source.GetType().Name}");
            }
        }

        public OperatorNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(OperatorNode)}");
    }
    public partial record OperatorNode : ConstantNode, IOperatorNode
    {
        public new const int EntityTag = 11;
        protected override int OnGetEntityTag() => EntityTag;


        public OperatorNode() : base()
        {
        }

        public OperatorNode(OperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public OperatorNode(IOperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public virtual bool Equals(OperatorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class BinaryOperatorNode_Factory : IEntityFactory<IBinaryOperatorNode, BinaryOperatorNode>
    {
        private static readonly BinaryOperatorNode_Factory _instance = new BinaryOperatorNode_Factory();
        public static BinaryOperatorNode_Factory Instance => _instance;

        public BinaryOperatorNode? CreateFrom(IBinaryOperatorNode? source)
        {
            if (source is null) return null;
            if (source is BinaryOperatorNode thisEntity) return thisEntity;
            return new BinaryOperatorNode(source);
        }

        private static readonly BinaryOperatorNode _empty = new BinaryOperatorNode();
        public BinaryOperatorNode Empty => _empty;
    }
    public partial record BinaryOperatorNode : OperatorNode, IBinaryOperatorNode
    {
        public new const int EntityTag = 12;
        protected override int OnGetEntityTag() => EntityTag;

        public BinaryOperator Value { get; init; }
        BinaryOperator IBinaryOperatorNode.Value => Value;

        public BinaryOperatorNode() : base()
        {
        }

        public BinaryOperatorNode(BinaryOperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public BinaryOperatorNode(IBinaryOperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Value = source.Value;
        }

        public virtual bool Equals(BinaryOperatorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Value.ValueEquals(other.Value)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class UnaryExpressionNode_Factory : IEntityFactory<IUnaryExpressionNode, UnaryExpressionNode>
    {
        private static readonly UnaryExpressionNode_Factory _instance = new UnaryExpressionNode_Factory();
        public static UnaryExpressionNode_Factory Instance => _instance;

        public UnaryExpressionNode? CreateFrom(IUnaryExpressionNode? source)
        {
            if (source is null) return null;
            if (source is UnaryExpressionNode thisEntity) return thisEntity;
            return new UnaryExpressionNode(source);
        }

        private static readonly UnaryExpressionNode _empty = new UnaryExpressionNode();
        public UnaryExpressionNode Empty => _empty;
    }
    public partial record UnaryExpressionNode : Node, IUnaryExpressionNode
    {
        public new const int EntityTag = 13;
        protected override int OnGetEntityTag() => EntityTag;

        public UnaryOperator Op { get; init; }
        UnaryOperator IUnaryExpressionNode.Op => Op;
        public Node? Operand { get; init; }
        INode? IUnaryExpressionNode.Operand => Operand;

        public UnaryExpressionNode() : base()
        {
        }

        public UnaryExpressionNode(UnaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Op = source.Op;
            Operand = source.Operand;
        }

        public UnaryExpressionNode(IUnaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Op = source.Op;
            Operand = Node_Factory.Instance.CreateFrom(source.Operand);
        }

        public virtual bool Equals(UnaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Op.ValueEquals(other.Op)) return false;
            if (!Operand.ValueEquals(other.Operand)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Op.CalcHashUnary());
            hc.Add(Operand.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class BinaryExpressionNode_Factory : IEntityFactory<IBinaryExpressionNode, BinaryExpressionNode>
    {
        private static readonly BinaryExpressionNode_Factory _instance = new BinaryExpressionNode_Factory();
        public static BinaryExpressionNode_Factory Instance => _instance;

        public BinaryExpressionNode? CreateFrom(IBinaryExpressionNode? source)
        {
            if (source is null) return null;
            if (source is BinaryExpressionNode thisEntity) return thisEntity;
            return new BinaryExpressionNode(source);
        }

        private static readonly BinaryExpressionNode _empty = new BinaryExpressionNode();
        public BinaryExpressionNode Empty => _empty;
    }
    public partial record BinaryExpressionNode : Node, IBinaryExpressionNode
    {
        public new const int EntityTag = 14;
        protected override int OnGetEntityTag() => EntityTag;

        public BinaryOperator Op { get; init; }
        BinaryOperator IBinaryExpressionNode.Op => Op;
        public Node? Left { get; init; }
        INode? IBinaryExpressionNode.Left => Left;
        public Node? Right { get; init; }
        INode? IBinaryExpressionNode.Right => Right;

        public BinaryExpressionNode() : base()
        {
        }

        public BinaryExpressionNode(BinaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Op = source.Op;
            Left = source.Left;
            Right = source.Right;
        }

        public BinaryExpressionNode(IBinaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Op = source.Op;
            Left = Node_Factory.Instance.CreateFrom(source.Left);
            Right = Node_Factory.Instance.CreateFrom(source.Right);
        }

        public virtual bool Equals(BinaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Op.ValueEquals(other.Op)) return false;
            if (!Left.ValueEquals(other.Left)) return false;
            if (!Right.ValueEquals(other.Right)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Op.CalcHashUnary());
            hc.Add(Left.CalcHashUnary());
            hc.Add(Right.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class TertiaryExpressionNode_Factory : IEntityFactory<ITertiaryExpressionNode, TertiaryExpressionNode>
    {
        private static readonly TertiaryExpressionNode_Factory _instance = new TertiaryExpressionNode_Factory();
        public static TertiaryExpressionNode_Factory Instance => _instance;

        public TertiaryExpressionNode? CreateFrom(ITertiaryExpressionNode? source)
        {
            if (source is null) return null;
            if (source is TertiaryExpressionNode thisEntity) return thisEntity;
            return new TertiaryExpressionNode(source);
        }

        private static readonly TertiaryExpressionNode _empty = new TertiaryExpressionNode();
        public TertiaryExpressionNode Empty => _empty;
    }
    public partial record TertiaryExpressionNode : Node, ITertiaryExpressionNode
    {
        public new const int EntityTag = 15;
        protected override int OnGetEntityTag() => EntityTag;

        public TertiaryOperator Op { get; init; }
        TertiaryOperator ITertiaryExpressionNode.Op => Op;
        public Node? Node1 { get; init; }
        INode? ITertiaryExpressionNode.Node1 => Node1;
        public Node? Node2 { get; init; }
        INode? ITertiaryExpressionNode.Node2 => Node2;
        public Node? Node3 { get; init; }
        INode? ITertiaryExpressionNode.Node3 => Node3;

        public TertiaryExpressionNode() : base()
        {
        }

        public TertiaryExpressionNode(TertiaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Op = source.Op;
            Node1 = source.Node1;
            Node2 = source.Node2;
            Node3 = source.Node3;
        }

        public TertiaryExpressionNode(ITertiaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Op = source.Op;
            Node1 = Node_Factory.Instance.CreateFrom(source.Node1);
            Node2 = Node_Factory.Instance.CreateFrom(source.Node2);
            Node3 = Node_Factory.Instance.CreateFrom(source.Node3);
        }

        public virtual bool Equals(TertiaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Op.ValueEquals(other.Op)) return false;
            if (!Node1.ValueEquals(other.Node1)) return false;
            if (!Node2.ValueEquals(other.Node2)) return false;
            if (!Node3.ValueEquals(other.Node3)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Op.CalcHashUnary());
            hc.Add(Node1.CalcHashUnary());
            hc.Add(Node2.CalcHashUnary());
            hc.Add(Node3.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }



}
