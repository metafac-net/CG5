#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: MessagePack.2.9
// Metadata : MetaFac.CG5.Expressions.Schema
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Memory;
using MetaFac.Mutability;
using MessagePack;
using MetaFac.CG4.Runtime;
using MetaFac.CG4.Runtime.MessagePack;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace MetaFac.CG5.Expressions.MessagePack
{


    public abstract partial class EntityBase : IFreezable, IEntityBase, IEquatable<EntityBase>, ICopyFrom<EntityBase>
    {
        public static EntityBase Empty => throw new NotSupportedException();
        public const int EntityTag = 0;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void ThrowIsReadonly()
        {
            throw new InvalidOperationException("Cannot set properties when frozen");
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected ref T CheckNotFrozen<T>(ref T value)
        {
            if (_isFrozen) ThrowIsReadonly();
            return ref value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void CheckNotFrozen()
        {
            if (_isFrozen) ThrowIsReadonly();
        }

        public EntityBase() { }
        public EntityBase(EntityBase source) { }
        public void CopyFrom(EntityBase source) => CheckNotFrozen();
        public EntityBase(IEntityBase source) { }
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();

        protected volatile bool _isFrozen = false;
        public bool IsFreezable() => true;
        public bool IsFrozen() => _isFrozen;
        protected virtual void OnFreeze() { }
        public void Freeze()
        {
            if (_isFrozen) return;
            OnFreeze();
            _isFrozen = true;
        }
        public bool TryFreeze()
        {
            if (_isFrozen) return false;
            OnFreeze();
            _isFrozen = true;
            return true;
        }

        public bool Equals(EntityBase? other) => true;
        public override bool Equals(object? obj) => obj is EntityBase other && this.Equals(other);
        public override int GetHashCode() => 0;
    }


    [Union(ErrorNode.EntityTag, typeof(ErrorNode))]
    [Union(ConstantNode.EntityTag, typeof(ConstantNode))]
    [Union(NullConstantNode.EntityTag, typeof(NullConstantNode))]
    [Union(BooleanConstantNode.EntityTag, typeof(BooleanConstantNode))]
    [Union(StringConstantNode.EntityTag, typeof(StringConstantNode))]
    [Union(NumericConstantNode.EntityTag, typeof(NumericConstantNode))]
    [Union(IntegerConstantNode.EntityTag, typeof(IntegerConstantNode))]
    [Union(DoubleConstantNode.EntityTag, typeof(DoubleConstantNode))]
    [Union(OperatorNode.EntityTag, typeof(OperatorNode))]
    [Union(BinaryOperatorNode.EntityTag, typeof(BinaryOperatorNode))]
    [Union(VariableNode.EntityTag, typeof(VariableNode))]
    [Union(UnaryExpressionNode.EntityTag, typeof(UnaryExpressionNode))]
    [Union(BinaryExpressionNode.EntityTag, typeof(BinaryExpressionNode))]
    [Union(TertiaryExpressionNode.EntityTag, typeof(TertiaryExpressionNode))]
    public abstract partial class Node
    {
    }
    public sealed class Node_Factory : IEntityFactory<INode, Node>
    {
        private static readonly Node_Factory _instance = new Node_Factory();
        public static Node_Factory Instance => _instance;

        public Node? CreateFrom(INode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case ErrorNode.EntityTag: return ErrorNode_Factory.Instance.CreateFrom((IErrorNode)source);
                case ConstantNode.EntityTag: return ConstantNode_Factory.Instance.CreateFrom((IConstantNode)source);
                case NullConstantNode.EntityTag: return NullConstantNode_Factory.Instance.CreateFrom((INullConstantNode)source);
                case BooleanConstantNode.EntityTag: return BooleanConstantNode_Factory.Instance.CreateFrom((IBooleanConstantNode)source);
                case StringConstantNode.EntityTag: return StringConstantNode_Factory.Instance.CreateFrom((IStringConstantNode)source);
                case NumericConstantNode.EntityTag: return NumericConstantNode_Factory.Instance.CreateFrom((INumericConstantNode)source);
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                case OperatorNode.EntityTag: return OperatorNode_Factory.Instance.CreateFrom((IOperatorNode)source);
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                case VariableNode.EntityTag: return VariableNode_Factory.Instance.CreateFrom((IVariableNode)source);
                case UnaryExpressionNode.EntityTag: return UnaryExpressionNode_Factory.Instance.CreateFrom((IUnaryExpressionNode)source);
                case BinaryExpressionNode.EntityTag: return BinaryExpressionNode_Factory.Instance.CreateFrom((IBinaryExpressionNode)source);
                case TertiaryExpressionNode.EntityTag: return TertiaryExpressionNode_Factory.Instance.CreateFrom((ITertiaryExpressionNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(Node)} from {source.GetType().Name}");
            }
        }

        public Node Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(Node)}");
    }
    [MessagePackObject]
    public partial class Node : EntityBase, INode, IEquatable<Node>, ICopyFrom<Node>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------

        // ---------- accessors ----------

        // ---------- INode methods ----------

        public Node()
        {
        }

        public Node(Node source) : base(source)
        {
        }

        public void CopyFrom(Node source)
        {
            base.CopyFrom(source);
        }

        public Node(INode source) : base(source)
        {
        }

        public bool Equals(Node? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        public static bool operator ==(Node left, Node right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Node left, Node right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Node other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class ErrorNode_Factory : IEntityFactory<IErrorNode, ErrorNode>
    {
        private static readonly ErrorNode_Factory _instance = new ErrorNode_Factory();
        public static ErrorNode_Factory Instance => _instance;

        public ErrorNode? CreateFrom(IErrorNode? source)
        {
            if (source is null) return null;
            if (source is ErrorNode sibling && sibling.IsFrozen()) return sibling;
            return new ErrorNode(source);
        }

        private static readonly ErrorNode _empty = new ErrorNode().Frozen();
        public ErrorNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class ErrorNode : Node, IErrorNode, IEquatable<ErrorNode>, ICopyFrom<ErrorNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 2;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private String? field_Message;

        // ---------- accessors ----------
        [Key(1)]
        public String? Message
        {
            get => field_Message;
            set => field_Message = CheckNotFrozen(ref value);
        }

        // ---------- IErrorNode methods ----------
        String? IErrorNode.Message => field_Message;

        public ErrorNode()
        {
        }

        public ErrorNode(ErrorNode source) : base(source)
        {
            field_Message = source.field_Message;
        }

        public void CopyFrom(ErrorNode source)
        {
            base.CopyFrom(source);
            field_Message = source.field_Message;
        }

        public ErrorNode(IErrorNode source) : base(source)
        {
            field_Message = source.Message;
        }

        public bool Equals(ErrorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Message.ValueEquals(other.field_Message)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(ErrorNode left, ErrorNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(ErrorNode left, ErrorNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is ErrorNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Message.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    [Union(NullConstantNode.EntityTag, typeof(NullConstantNode))]
    [Union(BooleanConstantNode.EntityTag, typeof(BooleanConstantNode))]
    [Union(StringConstantNode.EntityTag, typeof(StringConstantNode))]
    [Union(NumericConstantNode.EntityTag, typeof(NumericConstantNode))]
    [Union(IntegerConstantNode.EntityTag, typeof(IntegerConstantNode))]
    [Union(DoubleConstantNode.EntityTag, typeof(DoubleConstantNode))]
    [Union(OperatorNode.EntityTag, typeof(OperatorNode))]
    [Union(BinaryOperatorNode.EntityTag, typeof(BinaryOperatorNode))]
    public abstract partial class ConstantNode
    {
    }
    public sealed class ConstantNode_Factory : IEntityFactory<IConstantNode, ConstantNode>
    {
        private static readonly ConstantNode_Factory _instance = new ConstantNode_Factory();
        public static ConstantNode_Factory Instance => _instance;

        public ConstantNode? CreateFrom(IConstantNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case NullConstantNode.EntityTag: return NullConstantNode_Factory.Instance.CreateFrom((INullConstantNode)source);
                case BooleanConstantNode.EntityTag: return BooleanConstantNode_Factory.Instance.CreateFrom((IBooleanConstantNode)source);
                case StringConstantNode.EntityTag: return StringConstantNode_Factory.Instance.CreateFrom((IStringConstantNode)source);
                case NumericConstantNode.EntityTag: return NumericConstantNode_Factory.Instance.CreateFrom((INumericConstantNode)source);
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                case OperatorNode.EntityTag: return OperatorNode_Factory.Instance.CreateFrom((IOperatorNode)source);
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(ConstantNode)} from {source.GetType().Name}");
            }
        }

        public ConstantNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(ConstantNode)}");
    }
    [MessagePackObject]
    public partial class ConstantNode : Node, IConstantNode, IEquatable<ConstantNode>, ICopyFrom<ConstantNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 3;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------

        // ---------- accessors ----------

        // ---------- IConstantNode methods ----------

        public ConstantNode()
        {
        }

        public ConstantNode(ConstantNode source) : base(source)
        {
        }

        public void CopyFrom(ConstantNode source)
        {
            base.CopyFrom(source);
        }

        public ConstantNode(IConstantNode source) : base(source)
        {
        }

        public bool Equals(ConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        public static bool operator ==(ConstantNode left, ConstantNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(ConstantNode left, ConstantNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is ConstantNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class NullConstantNode_Factory : IEntityFactory<INullConstantNode, NullConstantNode>
    {
        private static readonly NullConstantNode_Factory _instance = new NullConstantNode_Factory();
        public static NullConstantNode_Factory Instance => _instance;

        public NullConstantNode? CreateFrom(INullConstantNode? source)
        {
            if (source is null) return null;
            if (source is NullConstantNode sibling && sibling.IsFrozen()) return sibling;
            return new NullConstantNode(source);
        }

        private static readonly NullConstantNode _empty = new NullConstantNode().Frozen();
        public NullConstantNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class NullConstantNode : ConstantNode, INullConstantNode, IEquatable<NullConstantNode>, ICopyFrom<NullConstantNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 4;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------

        // ---------- accessors ----------

        // ---------- INullConstantNode methods ----------

        public NullConstantNode()
        {
        }

        public NullConstantNode(NullConstantNode source) : base(source)
        {
        }

        public void CopyFrom(NullConstantNode source)
        {
            base.CopyFrom(source);
        }

        public NullConstantNode(INullConstantNode source) : base(source)
        {
        }

        public bool Equals(NullConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        public static bool operator ==(NullConstantNode left, NullConstantNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(NullConstantNode left, NullConstantNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is NullConstantNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class BooleanConstantNode_Factory : IEntityFactory<IBooleanConstantNode, BooleanConstantNode>
    {
        private static readonly BooleanConstantNode_Factory _instance = new BooleanConstantNode_Factory();
        public static BooleanConstantNode_Factory Instance => _instance;

        public BooleanConstantNode? CreateFrom(IBooleanConstantNode? source)
        {
            if (source is null) return null;
            if (source is BooleanConstantNode sibling && sibling.IsFrozen()) return sibling;
            return new BooleanConstantNode(source);
        }

        private static readonly BooleanConstantNode _empty = new BooleanConstantNode().Frozen();
        public BooleanConstantNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class BooleanConstantNode : ConstantNode, IBooleanConstantNode, IEquatable<BooleanConstantNode>, ICopyFrom<BooleanConstantNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 5;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Boolean field_Value;

        // ---------- accessors ----------
        [Key(1)]
        public Boolean Value
        {
            get => field_Value;
            set => field_Value = CheckNotFrozen(ref value);
        }

        // ---------- IBooleanConstantNode methods ----------
        Boolean IBooleanConstantNode.Value => field_Value.ToExternal();

        public BooleanConstantNode()
        {
        }

        public BooleanConstantNode(BooleanConstantNode source) : base(source)
        {
            field_Value = source.field_Value;
        }

        public void CopyFrom(BooleanConstantNode source)
        {
            base.CopyFrom(source);
            field_Value = source.field_Value;
        }

        public BooleanConstantNode(IBooleanConstantNode source) : base(source)
        {
            field_Value = source.Value.ToInternal();
        }

        public bool Equals(BooleanConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Value.ValueEquals(other.field_Value)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(BooleanConstantNode left, BooleanConstantNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(BooleanConstantNode left, BooleanConstantNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is BooleanConstantNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class StringConstantNode_Factory : IEntityFactory<IStringConstantNode, StringConstantNode>
    {
        private static readonly StringConstantNode_Factory _instance = new StringConstantNode_Factory();
        public static StringConstantNode_Factory Instance => _instance;

        public StringConstantNode? CreateFrom(IStringConstantNode? source)
        {
            if (source is null) return null;
            if (source is StringConstantNode sibling && sibling.IsFrozen()) return sibling;
            return new StringConstantNode(source);
        }

        private static readonly StringConstantNode _empty = new StringConstantNode().Frozen();
        public StringConstantNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class StringConstantNode : ConstantNode, IStringConstantNode, IEquatable<StringConstantNode>, ICopyFrom<StringConstantNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 6;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private String? field_Value;

        // ---------- accessors ----------
        [Key(1)]
        public String? Value
        {
            get => field_Value;
            set => field_Value = CheckNotFrozen(ref value);
        }

        // ---------- IStringConstantNode methods ----------
        String? IStringConstantNode.Value => field_Value;

        public StringConstantNode()
        {
        }

        public StringConstantNode(StringConstantNode source) : base(source)
        {
            field_Value = source.field_Value;
        }

        public void CopyFrom(StringConstantNode source)
        {
            base.CopyFrom(source);
            field_Value = source.field_Value;
        }

        public StringConstantNode(IStringConstantNode source) : base(source)
        {
            field_Value = source.Value;
        }

        public bool Equals(StringConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Value.ValueEquals(other.field_Value)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(StringConstantNode left, StringConstantNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(StringConstantNode left, StringConstantNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is StringConstantNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    [Union(IntegerConstantNode.EntityTag, typeof(IntegerConstantNode))]
    [Union(DoubleConstantNode.EntityTag, typeof(DoubleConstantNode))]
    public abstract partial class NumericConstantNode
    {
    }
    public sealed class NumericConstantNode_Factory : IEntityFactory<INumericConstantNode, NumericConstantNode>
    {
        private static readonly NumericConstantNode_Factory _instance = new NumericConstantNode_Factory();
        public static NumericConstantNode_Factory Instance => _instance;

        public NumericConstantNode? CreateFrom(INumericConstantNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(NumericConstantNode)} from {source.GetType().Name}");
            }
        }

        public NumericConstantNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(NumericConstantNode)}");
    }
    [MessagePackObject]
    public partial class NumericConstantNode : ConstantNode, INumericConstantNode, IEquatable<NumericConstantNode>, ICopyFrom<NumericConstantNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 7;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------

        // ---------- accessors ----------

        // ---------- INumericConstantNode methods ----------

        public NumericConstantNode()
        {
        }

        public NumericConstantNode(NumericConstantNode source) : base(source)
        {
        }

        public void CopyFrom(NumericConstantNode source)
        {
            base.CopyFrom(source);
        }

        public NumericConstantNode(INumericConstantNode source) : base(source)
        {
        }

        public bool Equals(NumericConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        public static bool operator ==(NumericConstantNode left, NumericConstantNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(NumericConstantNode left, NumericConstantNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is NumericConstantNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class IntegerConstantNode_Factory : IEntityFactory<IIntegerConstantNode, IntegerConstantNode>
    {
        private static readonly IntegerConstantNode_Factory _instance = new IntegerConstantNode_Factory();
        public static IntegerConstantNode_Factory Instance => _instance;

        public IntegerConstantNode? CreateFrom(IIntegerConstantNode? source)
        {
            if (source is null) return null;
            if (source is IntegerConstantNode sibling && sibling.IsFrozen()) return sibling;
            return new IntegerConstantNode(source);
        }

        private static readonly IntegerConstantNode _empty = new IntegerConstantNode().Frozen();
        public IntegerConstantNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class IntegerConstantNode : NumericConstantNode, IIntegerConstantNode, IEquatable<IntegerConstantNode>, ICopyFrom<IntegerConstantNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 8;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Int64 field_Value;

        // ---------- accessors ----------
        [Key(1)]
        public Int64 Value
        {
            get => field_Value;
            set => field_Value = CheckNotFrozen(ref value);
        }

        // ---------- IIntegerConstantNode methods ----------
        Int64 IIntegerConstantNode.Value => field_Value.ToExternal();

        public IntegerConstantNode()
        {
        }

        public IntegerConstantNode(IntegerConstantNode source) : base(source)
        {
            field_Value = source.field_Value;
        }

        public void CopyFrom(IntegerConstantNode source)
        {
            base.CopyFrom(source);
            field_Value = source.field_Value;
        }

        public IntegerConstantNode(IIntegerConstantNode source) : base(source)
        {
            field_Value = source.Value.ToInternal();
        }

        public bool Equals(IntegerConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Value.ValueEquals(other.field_Value)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(IntegerConstantNode left, IntegerConstantNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(IntegerConstantNode left, IntegerConstantNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is IntegerConstantNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class DoubleConstantNode_Factory : IEntityFactory<IDoubleConstantNode, DoubleConstantNode>
    {
        private static readonly DoubleConstantNode_Factory _instance = new DoubleConstantNode_Factory();
        public static DoubleConstantNode_Factory Instance => _instance;

        public DoubleConstantNode? CreateFrom(IDoubleConstantNode? source)
        {
            if (source is null) return null;
            if (source is DoubleConstantNode sibling && sibling.IsFrozen()) return sibling;
            return new DoubleConstantNode(source);
        }

        private static readonly DoubleConstantNode _empty = new DoubleConstantNode().Frozen();
        public DoubleConstantNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class DoubleConstantNode : NumericConstantNode, IDoubleConstantNode, IEquatable<DoubleConstantNode>, ICopyFrom<DoubleConstantNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 9;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Double field_Value;

        // ---------- accessors ----------
        [Key(1)]
        public Double Value
        {
            get => field_Value;
            set => field_Value = CheckNotFrozen(ref value);
        }

        // ---------- IDoubleConstantNode methods ----------
        Double IDoubleConstantNode.Value => field_Value.ToExternal();

        public DoubleConstantNode()
        {
        }

        public DoubleConstantNode(DoubleConstantNode source) : base(source)
        {
            field_Value = source.field_Value;
        }

        public void CopyFrom(DoubleConstantNode source)
        {
            base.CopyFrom(source);
            field_Value = source.field_Value;
        }

        public DoubleConstantNode(IDoubleConstantNode source) : base(source)
        {
            field_Value = source.Value.ToInternal();
        }

        public bool Equals(DoubleConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Value.ValueEquals(other.field_Value)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(DoubleConstantNode left, DoubleConstantNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(DoubleConstantNode left, DoubleConstantNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is DoubleConstantNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class VariableNode_Factory : IEntityFactory<IVariableNode, VariableNode>
    {
        private static readonly VariableNode_Factory _instance = new VariableNode_Factory();
        public static VariableNode_Factory Instance => _instance;

        public VariableNode? CreateFrom(IVariableNode? source)
        {
            if (source is null) return null;
            if (source is VariableNode sibling && sibling.IsFrozen()) return sibling;
            return new VariableNode(source);
        }

        private static readonly VariableNode _empty = new VariableNode().Frozen();
        public VariableNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class VariableNode : Node, IVariableNode, IEquatable<VariableNode>, ICopyFrom<VariableNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 10;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private String? field_Name;

        // ---------- accessors ----------
        [Key(1)]
        public String? Name
        {
            get => field_Name;
            set => field_Name = CheckNotFrozen(ref value);
        }

        // ---------- IVariableNode methods ----------
        String? IVariableNode.Name => field_Name;

        public VariableNode()
        {
        }

        public VariableNode(VariableNode source) : base(source)
        {
            field_Name = source.field_Name;
        }

        public void CopyFrom(VariableNode source)
        {
            base.CopyFrom(source);
            field_Name = source.field_Name;
        }

        public VariableNode(IVariableNode source) : base(source)
        {
            field_Name = source.Name;
        }

        public bool Equals(VariableNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Name.ValueEquals(other.field_Name)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(VariableNode left, VariableNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(VariableNode left, VariableNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is VariableNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Name.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    [Union(BinaryOperatorNode.EntityTag, typeof(BinaryOperatorNode))]
    public abstract partial class OperatorNode
    {
    }
    public sealed class OperatorNode_Factory : IEntityFactory<IOperatorNode, OperatorNode>
    {
        private static readonly OperatorNode_Factory _instance = new OperatorNode_Factory();
        public static OperatorNode_Factory Instance => _instance;

        public OperatorNode? CreateFrom(IOperatorNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(OperatorNode)} from {source.GetType().Name}");
            }
        }

        public OperatorNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(OperatorNode)}");
    }
    [MessagePackObject]
    public partial class OperatorNode : ConstantNode, IOperatorNode, IEquatable<OperatorNode>, ICopyFrom<OperatorNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 11;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------

        // ---------- accessors ----------

        // ---------- IOperatorNode methods ----------

        public OperatorNode()
        {
        }

        public OperatorNode(OperatorNode source) : base(source)
        {
        }

        public void CopyFrom(OperatorNode source)
        {
            base.CopyFrom(source);
        }

        public OperatorNode(IOperatorNode source) : base(source)
        {
        }

        public bool Equals(OperatorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }

        public static bool operator ==(OperatorNode left, OperatorNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(OperatorNode left, OperatorNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is OperatorNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class BinaryOperatorNode_Factory : IEntityFactory<IBinaryOperatorNode, BinaryOperatorNode>
    {
        private static readonly BinaryOperatorNode_Factory _instance = new BinaryOperatorNode_Factory();
        public static BinaryOperatorNode_Factory Instance => _instance;

        public BinaryOperatorNode? CreateFrom(IBinaryOperatorNode? source)
        {
            if (source is null) return null;
            if (source is BinaryOperatorNode sibling && sibling.IsFrozen()) return sibling;
            return new BinaryOperatorNode(source);
        }

        private static readonly BinaryOperatorNode _empty = new BinaryOperatorNode().Frozen();
        public BinaryOperatorNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class BinaryOperatorNode : OperatorNode, IBinaryOperatorNode, IEquatable<BinaryOperatorNode>, ICopyFrom<BinaryOperatorNode>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 12;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private BinaryOperator field_Value;

        // ---------- accessors ----------
        [Key(1)]
        public BinaryOperator Value
        {
            get => field_Value;
            set => field_Value = CheckNotFrozen(ref value);
        }

        // ---------- IBinaryOperatorNode methods ----------
        BinaryOperator IBinaryOperatorNode.Value => field_Value.ToExternal();

        public BinaryOperatorNode()
        {
        }

        public BinaryOperatorNode(BinaryOperatorNode source) : base(source)
        {
            field_Value = source.field_Value;
        }

        public void CopyFrom(BinaryOperatorNode source)
        {
            base.CopyFrom(source);
            field_Value = source.field_Value;
        }

        public BinaryOperatorNode(IBinaryOperatorNode source) : base(source)
        {
            field_Value = source.Value.ToInternal();
        }

        public bool Equals(BinaryOperatorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Value.ValueEquals(other.field_Value)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(BinaryOperatorNode left, BinaryOperatorNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(BinaryOperatorNode left, BinaryOperatorNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is BinaryOperatorNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Value.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class UnaryExpressionNode_Factory : IEntityFactory<IUnaryExpressionNode, UnaryExpressionNode>
    {
        private static readonly UnaryExpressionNode_Factory _instance = new UnaryExpressionNode_Factory();
        public static UnaryExpressionNode_Factory Instance => _instance;

        public UnaryExpressionNode? CreateFrom(IUnaryExpressionNode? source)
        {
            if (source is null) return null;
            if (source is UnaryExpressionNode sibling && sibling.IsFrozen()) return sibling;
            return new UnaryExpressionNode(source);
        }

        private static readonly UnaryExpressionNode _empty = new UnaryExpressionNode().Frozen();
        public UnaryExpressionNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class UnaryExpressionNode : Node, IUnaryExpressionNode, IEquatable<UnaryExpressionNode>, ICopyFrom<UnaryExpressionNode>
    {
        protected override void OnFreeze()
        {
            field_Operand?.Freeze();
            base.OnFreeze();
        }

        public new const int EntityTag = 13;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private UnaryOperator field_Op;
        private Node? field_Operand;

        // ---------- accessors ----------
        [Key(1)]
        public UnaryOperator Op
        {
            get => field_Op;
            set => field_Op = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Node? Operand
        {
            get => field_Operand;
            set => field_Operand = CheckNotFrozen(ref value);
        }

        // ---------- IUnaryExpressionNode methods ----------
        UnaryOperator IUnaryExpressionNode.Op => field_Op.ToExternal();
        INode? IUnaryExpressionNode.Operand => field_Operand;

        public UnaryExpressionNode()
        {
        }

        public UnaryExpressionNode(UnaryExpressionNode source) : base(source)
        {
            field_Op = source.field_Op;
            field_Operand = source.field_Operand;
        }

        public void CopyFrom(UnaryExpressionNode source)
        {
            base.CopyFrom(source);
            field_Op = source.field_Op;
            field_Operand = source.field_Operand;
        }

        public UnaryExpressionNode(IUnaryExpressionNode source) : base(source)
        {
            field_Op = source.Op.ToInternal();
            field_Operand = Node_Factory.Instance.CreateFrom(source.Operand);
        }

        public bool Equals(UnaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Op.ValueEquals(other.field_Op)) return false;
            if (!field_Operand.ValueEquals(other.field_Operand)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(UnaryExpressionNode left, UnaryExpressionNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(UnaryExpressionNode left, UnaryExpressionNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is UnaryExpressionNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Op.CalcHashUnary());
            hc.Add(field_Operand.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class BinaryExpressionNode_Factory : IEntityFactory<IBinaryExpressionNode, BinaryExpressionNode>
    {
        private static readonly BinaryExpressionNode_Factory _instance = new BinaryExpressionNode_Factory();
        public static BinaryExpressionNode_Factory Instance => _instance;

        public BinaryExpressionNode? CreateFrom(IBinaryExpressionNode? source)
        {
            if (source is null) return null;
            if (source is BinaryExpressionNode sibling && sibling.IsFrozen()) return sibling;
            return new BinaryExpressionNode(source);
        }

        private static readonly BinaryExpressionNode _empty = new BinaryExpressionNode().Frozen();
        public BinaryExpressionNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class BinaryExpressionNode : Node, IBinaryExpressionNode, IEquatable<BinaryExpressionNode>, ICopyFrom<BinaryExpressionNode>
    {
        protected override void OnFreeze()
        {
            field_Left?.Freeze();
            field_Right?.Freeze();
            base.OnFreeze();
        }

        public new const int EntityTag = 14;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private BinaryOperator field_Op;
        private Node? field_Left;
        private Node? field_Right;

        // ---------- accessors ----------
        [Key(1)]
        public BinaryOperator Op
        {
            get => field_Op;
            set => field_Op = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Node? Left
        {
            get => field_Left;
            set => field_Left = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public Node? Right
        {
            get => field_Right;
            set => field_Right = CheckNotFrozen(ref value);
        }

        // ---------- IBinaryExpressionNode methods ----------
        BinaryOperator IBinaryExpressionNode.Op => field_Op.ToExternal();
        INode? IBinaryExpressionNode.Left => field_Left;
        INode? IBinaryExpressionNode.Right => field_Right;

        public BinaryExpressionNode()
        {
        }

        public BinaryExpressionNode(BinaryExpressionNode source) : base(source)
        {
            field_Op = source.field_Op;
            field_Left = source.field_Left;
            field_Right = source.field_Right;
        }

        public void CopyFrom(BinaryExpressionNode source)
        {
            base.CopyFrom(source);
            field_Op = source.field_Op;
            field_Left = source.field_Left;
            field_Right = source.field_Right;
        }

        public BinaryExpressionNode(IBinaryExpressionNode source) : base(source)
        {
            field_Op = source.Op.ToInternal();
            field_Left = Node_Factory.Instance.CreateFrom(source.Left);
            field_Right = Node_Factory.Instance.CreateFrom(source.Right);
        }

        public bool Equals(BinaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Op.ValueEquals(other.field_Op)) return false;
            if (!field_Left.ValueEquals(other.field_Left)) return false;
            if (!field_Right.ValueEquals(other.field_Right)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(BinaryExpressionNode left, BinaryExpressionNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(BinaryExpressionNode left, BinaryExpressionNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is BinaryExpressionNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Op.CalcHashUnary());
            hc.Add(field_Left.CalcHashUnary());
            hc.Add(field_Right.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class TertiaryExpressionNode_Factory : IEntityFactory<ITertiaryExpressionNode, TertiaryExpressionNode>
    {
        private static readonly TertiaryExpressionNode_Factory _instance = new TertiaryExpressionNode_Factory();
        public static TertiaryExpressionNode_Factory Instance => _instance;

        public TertiaryExpressionNode? CreateFrom(ITertiaryExpressionNode? source)
        {
            if (source is null) return null;
            if (source is TertiaryExpressionNode sibling && sibling.IsFrozen()) return sibling;
            return new TertiaryExpressionNode(source);
        }

        private static readonly TertiaryExpressionNode _empty = new TertiaryExpressionNode().Frozen();
        public TertiaryExpressionNode Empty => _empty;
    }
    [MessagePackObject]
    public partial class TertiaryExpressionNode : Node, ITertiaryExpressionNode, IEquatable<TertiaryExpressionNode>, ICopyFrom<TertiaryExpressionNode>
    {
        protected override void OnFreeze()
        {
            field_Node1?.Freeze();
            field_Node2?.Freeze();
            field_Node3?.Freeze();
            base.OnFreeze();
        }

        public new const int EntityTag = 15;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private TertiaryOperator field_Op;
        private Node? field_Node1;
        private Node? field_Node2;
        private Node? field_Node3;

        // ---------- accessors ----------
        [Key(1)]
        public TertiaryOperator Op
        {
            get => field_Op;
            set => field_Op = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Node? Node1
        {
            get => field_Node1;
            set => field_Node1 = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public Node? Node2
        {
            get => field_Node2;
            set => field_Node2 = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public Node? Node3
        {
            get => field_Node3;
            set => field_Node3 = CheckNotFrozen(ref value);
        }

        // ---------- ITertiaryExpressionNode methods ----------
        TertiaryOperator ITertiaryExpressionNode.Op => field_Op.ToExternal();
        INode? ITertiaryExpressionNode.Node1 => field_Node1;
        INode? ITertiaryExpressionNode.Node2 => field_Node2;
        INode? ITertiaryExpressionNode.Node3 => field_Node3;

        public TertiaryExpressionNode()
        {
        }

        public TertiaryExpressionNode(TertiaryExpressionNode source) : base(source)
        {
            field_Op = source.field_Op;
            field_Node1 = source.field_Node1;
            field_Node2 = source.field_Node2;
            field_Node3 = source.field_Node3;
        }

        public void CopyFrom(TertiaryExpressionNode source)
        {
            base.CopyFrom(source);
            field_Op = source.field_Op;
            field_Node1 = source.field_Node1;
            field_Node2 = source.field_Node2;
            field_Node3 = source.field_Node3;
        }

        public TertiaryExpressionNode(ITertiaryExpressionNode source) : base(source)
        {
            field_Op = source.Op.ToInternal();
            field_Node1 = Node_Factory.Instance.CreateFrom(source.Node1);
            field_Node2 = Node_Factory.Instance.CreateFrom(source.Node2);
            field_Node3 = Node_Factory.Instance.CreateFrom(source.Node3);
        }

        public bool Equals(TertiaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Op.ValueEquals(other.field_Op)) return false;
            if (!field_Node1.ValueEquals(other.field_Node1)) return false;
            if (!field_Node2.ValueEquals(other.field_Node2)) return false;
            if (!field_Node3.ValueEquals(other.field_Node3)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(TertiaryExpressionNode left, TertiaryExpressionNode right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(TertiaryExpressionNode left, TertiaryExpressionNode right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is TertiaryExpressionNode other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Op.CalcHashUnary());
            hc.Add(field_Node1.CalcHashUnary());
            hc.Add(field_Node2.CalcHashUnary());
            hc.Add(field_Node3.CalcHashUnary());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }


}
